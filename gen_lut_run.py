## batch run 6SV1.1 with the inputs that generated by "gen_lut_inputs_for_wise.py"
## and extract the aerosol reflectance and transmittance for the output files
## the program goes more and more slowly when run and extract at the same time
## so, it is seperated to save time


import subprocess as subp
import os,sys
import numpy as np
import logging
from configparser import ConfigParser
import tables
from tables import *
from tables import Float32Atom
from tables import Filters
import glob
import psutil
import ray
import time
from new_lut.gen_lut_inputs_for_wise import *

logger = logging.getLogger('simple_example')
logger.setLevel(logging.INFO)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# add formatter to ch
ch.setFormatter(formatter)
# add ch to logger
logger.addHandler(ch)

dict_line = {'spherical albedo':-17,'reflectance I':-14,'trans':-24}

def extract_aerosol(outputs_lines:list,inupt_name):
    lines = [line.replace('*','') for line in outputs_lines]
    # Split into lines

    # There should be hundreds of lines for a full 6S run - so if there are
    # less than 10 then it suggests something has gone seriously wrong
    if len(lines) < 10:
        logger.warning("6S didn't return a full output. See raw 6S output above for "
                                 "more information and check for invalid parameter inputs")
        logger.warning(inupt_name)
        return np.nan,np.nan,np.nan,np.nan

    s_albedo = lines[dict_line['spherical albedo']]
    s_reflectance_I = lines[dict_line['reflectance I']]
    s_trans = lines[dict_line['trans']]

    title,values_str = s_albedo.split(':')[0].strip(),s_albedo.split(':')[1].strip()
    if title.find('albedo')<0:
        logger.error("spherical albedo: {}".format(inupt_name))
    values = [float(v) for v in values_str.split(' ') if v != '']
    aerosol_albedo = values[1]

    title,values_str = s_reflectance_I.split(':')[0].strip(),s_reflectance_I.split(':')[1].strip()
    if title.find('reflectance')<0:
        logger.error("reflectance I: {}".format(inupt_name))
    values = [float(v) for v in values_str.split(' ') if v != '']
    aerosol_reflectance_I = values[1]

    title,values_str = s_trans.split(':')[0].strip(),s_trans.split(':')[1].strip()
    if title.find('aeros. sca')<0:
        logger.error("aeros. sca: {}".format(inupt_name))
    values = [float(v) for v in values_str.split(' ') if v != '']
    aerosol_trans_up, aerosol_trans_down = values[1],values[0]

    return  aerosol_albedo,aerosol_reflectance_I,aerosol_trans_up,aerosol_trans_down


def run_extract_all_wavelengths(sixs_path,input_dir,i_para,n_waves):
    '''
    :param i_para:
    :param n_waves:
    :return:
    '''
    aerosol_albedo_w,aerosol_reflectance_I_w,aerosol_trans_up_w,aerosol_trans_down_w = [],[],[],[]
    for i_w in range(n_waves):
        tmp_file_name = os.path.join(input_dir,"6SV_{}_{}.txt".format(i_para,i_w))
        logger.debug("%s < %s" % (sixs_path, tmp_file_name))
        process = subp.Popen("%s < %s" % (sixs_path, tmp_file_name),
                             shell=True, stdout=subp.PIPE,
                             stderr=subp.PIPE)
        outputs = process.communicate()
        output_lines = outputs[0].replace('*','').splitlines()
        aerosol_albedo, aerosol_reflectance_I, aerosol_trans_up, aerosol_trans_down = extract_aerosol(output_lines,tmp_file_name)
        aerosol_albedo_w.append(aerosol_albedo)
        aerosol_reflectance_I_w.append(aerosol_reflectance_I)
        aerosol_trans_up_w.append(aerosol_trans_up)
        aerosol_trans_down_w.append(aerosol_trans_down)
    return aerosol_albedo_w,aerosol_reflectance_I_w,aerosol_trans_up_w,aerosol_trans_down_w

def extract_all_wavelengths(sixs_path,out_dir,i_para,n_waves):
    '''
    extract spectrum form the output file of 6SV
    :param sixs_path:
    :param out_dir: the dir where the output files is
    :param i_para: index of the parameter
    :param n_waves: number of bands
    :return:
    '''
    aerosol_albedo_w,aerosol_reflectance_I_w,aerosol_trans_up_w,aerosol_trans_down_w = [],[],[],[]
    for i_w in range(n_waves):
        output_file = os.path.join(out_dir,'6SV_{}_{}_out.txt'.format(i_para,i_w))
        with open(output_file,'r') as f:
            outputs_lines = f.readlines()
        #logger.info(outputs_lines)
        #logger.info(output_file)
        aerosol_albedo, aerosol_reflectance_I, aerosol_trans_up, aerosol_trans_down = extract_aerosol(outputs_lines,output_file)
        aerosol_albedo_w.append(aerosol_albedo)
        aerosol_reflectance_I_w.append(aerosol_reflectance_I)
        aerosol_trans_up_w.append(aerosol_trans_up)
        aerosol_trans_down_w.append(aerosol_trans_down)
    return aerosol_albedo_w, aerosol_reflectance_I_w, aerosol_trans_up_w, aerosol_trans_down_w

def extract_aerosoltype(config_input,aero_coms,aerosl_type_index):

    sz = parser_parmeter(config_input['Geo']['sz'])
    vz = parser_parmeter(config_input['Geo']['vz'])
    phi = parser_parmeter(config_input['Geo']['phi'])
    sixs_path = config_input['6SV']['sixs']
    taua550 = parser_parmeter(config_input['Aerosol']['taua550'])

    n_para = len(sz)*len(vz)*len(phi)*len(taua550)
    n_waves = len(waves_wise)

    input_dir_ = config_input['IO']['out_dir']
    output_dir = os.path.join(os.path.split(input_dir_)[0],'output')
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    input_dir = os.path.join(input_dir_, 'aerosol_{}'.format(aerosl_type_index))

    shape = (n_para, n_waves)
    atom = Float32Atom()
    atom_int = Int16Atom()
    filters = Filters(complevel=5, complib='zlib')

    output_name = 'aerosol_midlatsummer_{}_{}_{}.h5'.format(config_input['WISE']['altitude'], config_input['Ground']['altitude'],aerosl_type_index)

    h5f = tables.open_file(os.path.join(output_dir, output_name), 'w', title='Aerosol scattering LUT for the WISE sensor')
    h5f.root._v_attrs.Author = 'Yanqun Pan,UQAR,panyq213@163.com'
    h5f.root._v_attrs.AerosolType = str(aero_coms[aerosl_type_index])
    h5f.root._v_attrs.DimensionOrder = '(taua550,sz,vz,phi)'
    ca_wavelength = h5f.create_carray(h5f.root, 'wavelength', atom, (n_waves,), filters=filters,
                                      title='wavelength')
    ca_sz = h5f.create_carray(h5f.root, 'solar_zenith', atom, (len(sz),), filters=filters,
                              title='solar zenith angle (degree)')
    ca_vz = h5f.create_carray(h5f.root, 'viewing_zenith', atom, (len(vz),), filters=filters,
                              title='viewing zenith angle (degree)')
    ca_phi = h5f.create_carray(h5f.root, 'relative_azimuth', atom, (len(phi),), filters=filters,
                               title='relative azimuth (degree)')
    ca_taua550 = h5f.create_carray(h5f.root, 'taua_550', atom, (len(taua550),), filters=filters,
                                   title='relative azimuth (degree)')

    ca_rhoa = h5f.create_carray(h5f.root, 'aerosol_reflectance', atom, shape, filters=filters,
                                title='aerosol reflectance')
    ca_spherical_albedo = h5f.create_carray(h5f.root, 'spherical_albedo', atom, shape, filters=filters,
                                title='spherical albedo')
    ca_transa_up = h5f.create_carray(h5f.root, 'aerosol_trans_up', atom, shape, filters=filters,
                                     title='upwelling transmittance due to aerosol scattering ')
    ca_transa_down = h5f.create_carray(h5f.root, 'aerosol_trans_down', atom, shape, filters=filters,
                                       title='downwelling transmittance due to aerosol scattering')

    ca_wavelength[:] = waves_wise
    ca_sz[:] = np.asarray(sz)
    ca_vz[:] = np.asarray(vz)
    ca_phi[:] = np.asarray(phi)
    ca_taua550[:] = np.asarray(taua550)

    
    for i_para in tqdm(range(n_para)[:]):
        aerosol_albedo_w, aerosol_reflectance_I_w, aerosol_trans_up_w, aerosol_trans_down_w = extract_all_wavelengths(sixs_path, os.path.join(output_dir,'aerosol_{}'.format(aerosl_type_index)), i_para, n_waves)

        ca_rhoa[i_para,:] = np.asarray(aerosol_reflectance_I_w)
        ca_transa_up[i_para,:] = np.asarray(aerosol_trans_up_w)
        ca_transa_down[i_para, :] = np.asarray(aerosol_trans_down_w)
        ca_spherical_albedo[i_para, :] = np.asarray(aerosol_albedo_w)

    h5f.close()


def batch_run(config_input,aerosl_type_index):
    '''
    slower and slower
    :param config_input:
    :param aerosl_type_index:
    :return:
    '''
    sixs_path = config_input['6SV']['sixs']
    input_dir_ = config_input['IO']['out_dir']
    output_dir_ = os.path.join(os.path.split(input_dir_)[0], 'output')
    if not os.path.exists(output_dir_):
        os.mkdir(output_dir_)

    input_dir = os.path.join(input_dir_, 'aerosol_{}'.format(aerosl_type_index))
    output_dir = os.path.join(output_dir_,'aerosol_{}'.format(aerosl_type_index))
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)
    inputs = glob.glob(os.path.join(input_dir,'6SV*.txt'))

    for i in tqdm(range(len(inputs))):
        output = os.path.join(output_dir, os.path.split(inputs[i])[-1].replace('.txt', '_out.txt'))
        if os.path.exists(output):
            continue
        str_run ="{} < {} > {}".format(sixs_path, inputs[i],output)
        logger.debug(str_run)
        os.system(str_run)

def run_ray(config_input,aerosl_type_index):
    '''
    much faster than multiprocessing
    :param config_input:
    :param aerosl_type_index:
    :return:
    '''
    sixs_path = config_input['6SV']['sixs']
    input_dir_ = config_input['IO']['out_dir']
    output_dir_ = os.path.join(os.path.split(input_dir_)[0], 'output')
    if not os.path.exists(output_dir_):
        os.mkdir(output_dir_)

    input_dir = os.path.join(input_dir_, 'aerosol_{}'.format(aerosl_type_index))
    output_dir = os.path.join(output_dir_,'aerosol_{}'.format(aerosl_type_index))
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)
    inputs = glob.glob(os.path.join(input_dir,'6SV*.txt'))

    @ray.remote
    def run(j):
        output = os.path.join(output_dir, os.path.split(inputs[j])[-1].replace('.txt', '_out.txt'))
        if os.path.exists(output):
            return 0
        str_run ="{} < {} > {}".format(sixs_path, inputs[j],output)
        logger.debug(str_run)
        res = os.system(str_run)
        return res

    ray.get([run.remote(k) for k in range(len(inputs))])

if __name__ == '__main__':
    if len(sys.argv)<3:
        print('need the config file when generate inputs and command name,like run,extract')
        exit(-1)

    confg_input = ConfigParser()
    confg_input.read(sys.argv[1])
    command = sys.argv[2]
    start_i, end_i = int(confg_input['Aerosol']['start_i']), int(confg_input['Aerosol']['end_i'])
    aero_coms = genUsrDefineAerosolType()

    if command == 'extract':
        for i in range(start_i,end_i):
            extract_aerosoltype(confg_input,aero_coms,i)
    elif command == 'run':
        for i in range(start_i,end_i):
            batch_run(confg_input,i)

    elif command == 'run_ray':
        num_cpus = psutil.cpu_count(logical=False)
        ray.init(num_cpus=num_cpus)
        for i in range(start_i,end_i):
            run_ray(confg_input,i)








